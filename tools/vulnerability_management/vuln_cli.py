#!/usr/bin/env python3
"""
Vulnerability Management CLI - Command-line interface for vulnerability operations.

Commands: import, score, assign, report, track
"""

import argparse
import json
import sys
from datetime import datetime
from pathlib import Path
from typing import Optional

from .compliance_reporter import ComplianceReporter
from .defectdojo_client import DefectDojoClient, DefectDojoConfig
from .remediation_tracker import RemediationStatus, RemediationTracker
from .risk_scorer import CVSSVector, RiskScorer
from .trend_analyzer import TrendAnalyzer
from .vulnerability_aggregator import Severity, VulnerabilityAggregator


def create_parser() -> argparse.ArgumentParser:
    """Create CLI argument parser."""
    parser = argparse.ArgumentParser(
        prog="vuln_cli",
        description="Vulnerability Management Platform CLI for devCrew_s1",
    )
    parser.add_argument(
        "--version", action="version", version="%(prog)s 1.0.0"
    )

    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    # Import command
    import_parser = subparsers.add_parser("import", help="Import vulnerability reports")
    import_parser.add_argument("file", help="Path to vulnerability report file")
    import_parser.add_argument(
        "--format",
        choices=["sarif", "json", "xml", "auto"],
        default="auto",
        help="Report format (default: auto-detect)",
    )
    import_parser.add_argument(
        "--output", "-o", help="Output file for imported vulnerabilities"
    )

    # Score command
    score_parser = subparsers.add_parser("score", help="Score vulnerabilities")
    score_parser.add_argument("file", help="Path to vulnerabilities JSON file")
    score_parser.add_argument(
        "--vector", help="CVSS vector string (e.g., CVSS:3.1/AV:N/AC:L/...)"
    )
    score_parser.add_argument(
        "--prioritize", action="store_true", help="Output prioritized list"
    )
    score_parser.add_argument("--output", "-o", help="Output file for scores")

    # Assign command
    assign_parser = subparsers.add_parser("assign", help="Assign vulnerabilities for remediation")
    assign_parser.add_argument("file", help="Path to vulnerabilities JSON file")
    assign_parser.add_argument("--assignee", "-a", required=True, help="Assignee name/email")
    assign_parser.add_argument(
        "--severity",
        choices=["critical", "high", "medium", "low", "info"],
        help="Filter by severity",
    )
    assign_parser.add_argument("--output", "-o", help="Output file for tasks")

    # Report command
    report_parser = subparsers.add_parser("report", help="Generate compliance reports")
    report_parser.add_argument("file", help="Path to vulnerabilities JSON file")
    report_parser.add_argument(
        "--framework",
        choices=["owasp", "cwe", "pci", "summary"],
        default="summary",
        help="Compliance framework",
    )
    report_parser.add_argument("--output", "-o", help="Output file for report")

    # Track command
    track_parser = subparsers.add_parser("track", help="Track remediation progress")
    track_parser.add_argument("tasks_file", help="Path to tasks JSON file")
    track_parser.add_argument(
        "--action",
        choices=["status", "transition", "metrics", "sla"],
        default="status",
        help="Tracking action",
    )
    track_parser.add_argument("--task-id", help="Task ID for transition")
    track_parser.add_argument(
        "--new-status",
        choices=["in_progress", "in_review", "resolved", "accepted_risk", "false_positive"],
        help="New status for transition",
    )
    track_parser.add_argument("--output", "-o", help="Output file")

    return parser


def cmd_import(args: argparse.Namespace) -> int:
    """Handle import command."""
    aggregator = VulnerabilityAggregator()
    file_path = Path(args.file)

    if not file_path.exists():
        print(f"Error: File not found: {args.file}", file=sys.stderr)
        return 1

    # Auto-detect format
    format_type = args.format
    if format_type == "auto":
        suffix = file_path.suffix.lower()
        if suffix == ".sarif":
            format_type = "sarif"
        elif suffix == ".xml":
            format_type = "xml"
        else:
            format_type = "json"

    try:
        if format_type == "sarif":
            vulns = aggregator.parse_sarif(str(file_path))
        elif format_type == "xml":
            vulns = aggregator.parse_xml(str(file_path))
        else:
            vulns = aggregator.parse_json(str(file_path))

        print(f"Imported {len(vulns)} vulnerabilities from {file_path.name}")
        print(f"Statistics: {json.dumps(aggregator.statistics(), indent=2)}")

        if args.output:
            aggregator.export_json(args.output)
            print(f"Exported to {args.output}")

        return 0
    except Exception as e:
        print(f"Error importing file: {e}", file=sys.stderr)
        return 1


def cmd_score(args: argparse.Namespace) -> int:
    """Handle score command."""
    aggregator = VulnerabilityAggregator()
    scorer = RiskScorer()

    try:
        vulns = aggregator.parse_json(args.file)

        if args.vector:
            vector = CVSSVector.from_vector_string(args.vector)
            print(f"CVSS Vector: {vector.to_vector_string()}")
            print(f"Base Score: {scorer.calculate_base_score(vector)}")

        # Score all vulnerabilities
        for vuln in vulns:
            score = scorer.score_vulnerability(vuln)
            vuln.metadata["calculated_score"] = score

        if args.prioritize:
            vulns = scorer.prioritize(vulns)
            print("\nPrioritized Vulnerabilities:")
            for i, vuln in enumerate(vulns[:10], 1):
                score = vuln.metadata.get("calculated_score", 0)
                print(f"  {i}. [{score:.1f}] {vuln.title} ({vuln.severity.value})")

        summary = scorer.get_risk_summary(vulns)
        print(f"\nRisk Summary: {json.dumps(summary, indent=2)}")

        if args.output:
            output_data = [v.to_dict() for v in vulns]
            with open(args.output, "w", encoding="utf-8") as f:
                json.dump(output_data, f, indent=2)
            print(f"Exported to {args.output}")

        return 0
    except Exception as e:
        print(f"Error scoring vulnerabilities: {e}", file=sys.stderr)
        return 1


def cmd_assign(args: argparse.Namespace) -> int:
    """Handle assign command."""
    aggregator = VulnerabilityAggregator()
    tracker = RemediationTracker()

    try:
        vulns = aggregator.parse_json(args.file)

        # Filter by severity if specified
        if args.severity:
            target_severity = Severity(args.severity)
            vulns = [v for v in vulns if v.severity == target_severity]

        tasks = []
        for vuln in vulns:
            task = tracker.create_task(vuln, assignee=args.assignee)
            tasks.append(task)
            print(f"Created {task.task_id}: {vuln.title} -> {args.assignee}")

        print(f"\nAssigned {len(tasks)} vulnerabilities to {args.assignee}")

        if args.output:
            output_data = [t.to_dict() for t in tasks]
            with open(args.output, "w", encoding="utf-8") as f:
                json.dump(output_data, f, indent=2)
            print(f"Exported to {args.output}")

        return 0
    except Exception as e:
        print(f"Error assigning vulnerabilities: {e}", file=sys.stderr)
        return 1


def cmd_report(args: argparse.Namespace) -> int:
    """Handle report command."""
    aggregator = VulnerabilityAggregator()
    reporter = ComplianceReporter()

    try:
        vulns = aggregator.parse_json(args.file)

        if args.framework == "owasp":
            report = reporter.generate_owasp_report(vulns)
        elif args.framework == "cwe":
            report = reporter.generate_cwe_report(vulns)
        elif args.framework == "pci":
            report = reporter.generate_pci_dss_report(vulns)
        else:
            report = reporter.generate_executive_summary(vulns)

        print(json.dumps(report, indent=2))

        if args.output:
            reporter.export_report(report, args.output)
            print(f"\nExported to {args.output}")

        return 0
    except Exception as e:
        print(f"Error generating report: {e}", file=sys.stderr)
        return 1


def cmd_track(args: argparse.Namespace) -> int:
    """Handle track command."""
    try:
        with open(args.tasks_file, "r", encoding="utf-8") as f:
            tasks_data = json.load(f)

        # Rebuild tracker from saved tasks (simplified for CLI)
        if args.action == "status":
            print(f"Tasks loaded: {len(tasks_data)}")
            for task in tasks_data:
                status = task.get("status", "unknown")
                overdue = " [OVERDUE]" if task.get("is_overdue") else ""
                print(f"  {task['task_id']}: {status}{overdue}")

        elif args.action == "metrics":
            total = len(tasks_data)
            resolved = sum(1 for t in tasks_data if t.get("status") == "resolved")
            overdue = sum(1 for t in tasks_data if t.get("is_overdue"))
            print(f"Total tasks: {total}")
            print(f"Resolved: {resolved}")
            print(f"Overdue: {overdue}")

        elif args.action == "sla":
            overdue = [t for t in tasks_data if t.get("is_overdue")]
            print(f"SLA Violations: {len(overdue)}")
            for task in overdue:
                print(f"  {task['task_id']}: {task.get('days_open', 0)} days open")

        elif args.action == "transition":
            if not args.task_id or not args.new_status:
                print("Error: --task-id and --new-status required for transition", file=sys.stderr)
                return 1
            print(f"Note: Transition not persisted in file-based CLI mode")
            print(f"Would transition {args.task_id} to {args.new_status}")

        return 0
    except Exception as e:
        print(f"Error tracking tasks: {e}", file=sys.stderr)
        return 1


def main(argv: Optional[list] = None) -> int:
    """Main CLI entry point."""
    parser = create_parser()
    args = parser.parse_args(argv)

    if not args.command:
        parser.print_help()
        return 0

    commands = {
        "import": cmd_import,
        "score": cmd_score,
        "assign": cmd_assign,
        "report": cmd_report,
        "track": cmd_track,
    }

    handler = commands.get(args.command)
    if handler:
        return handler(args)
    else:
        parser.print_help()
        return 1


if __name__ == "__main__":
    sys.exit(main())
