"""
Remediation Tracker - Workflow states, assignees, due dates, and SLA monitoring.

Tracks vulnerability remediation lifecycle.
"""

from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
from typing import Any, Dict, List, Optional

from .vulnerability_aggregator import Severity, Vulnerability


class RemediationStatus(Enum):
    """Remediation workflow states."""

    OPEN = "open"
    IN_PROGRESS = "in_progress"
    IN_REVIEW = "in_review"
    RESOLVED = "resolved"
    ACCEPTED_RISK = "accepted_risk"
    FALSE_POSITIVE = "false_positive"
    REOPENED = "reopened"


# Valid state transitions
VALID_TRANSITIONS: Dict[RemediationStatus, List[RemediationStatus]] = {
    RemediationStatus.OPEN: [
        RemediationStatus.IN_PROGRESS,
        RemediationStatus.ACCEPTED_RISK,
        RemediationStatus.FALSE_POSITIVE,
    ],
    RemediationStatus.IN_PROGRESS: [
        RemediationStatus.IN_REVIEW,
        RemediationStatus.OPEN,
    ],
    RemediationStatus.IN_REVIEW: [
        RemediationStatus.RESOLVED,
        RemediationStatus.IN_PROGRESS,
    ],
    RemediationStatus.RESOLVED: [
        RemediationStatus.REOPENED,
    ],
    RemediationStatus.ACCEPTED_RISK: [
        RemediationStatus.OPEN,
    ],
    RemediationStatus.FALSE_POSITIVE: [
        RemediationStatus.OPEN,
    ],
    RemediationStatus.REOPENED: [
        RemediationStatus.IN_PROGRESS,
        RemediationStatus.ACCEPTED_RISK,
    ],
}


@dataclass
class RemediationTask:
    """Remediation task for a vulnerability."""

    task_id: str
    vulnerability: Vulnerability
    status: RemediationStatus = RemediationStatus.OPEN
    assignee: Optional[str] = None
    due_date: Optional[datetime] = None
    created_at: datetime = field(default_factory=datetime.now)
    updated_at: datetime = field(default_factory=datetime.now)
    resolved_at: Optional[datetime] = None
    notes: List[str] = field(default_factory=list)
    history: List[Dict[str, Any]] = field(default_factory=list)

    def __post_init__(self) -> None:
        """Initialize history."""
        if not self.history:
            self.history.append({
                "timestamp": self.created_at.isoformat(),
                "action": "created",
                "status": self.status.value,
            })

    @property
    def is_overdue(self) -> bool:
        """Check if task is overdue."""
        if self.due_date is None:
            return False
        if self.status in (RemediationStatus.RESOLVED, RemediationStatus.FALSE_POSITIVE):
            return False
        return datetime.now() > self.due_date

    @property
    def days_open(self) -> int:
        """Days since task was created."""
        end = self.resolved_at or datetime.now()
        return (end - self.created_at).days

    @property
    def time_to_resolution(self) -> Optional[timedelta]:
        """Time from creation to resolution."""
        if self.resolved_at:
            return self.resolved_at - self.created_at
        return None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            "task_id": self.task_id,
            "vulnerability_id": self.vulnerability.vuln_id,
            "fingerprint": self.vulnerability.fingerprint,
            "status": self.status.value,
            "assignee": self.assignee,
            "due_date": self.due_date.isoformat() if self.due_date else None,
            "created_at": self.created_at.isoformat(),
            "updated_at": self.updated_at.isoformat(),
            "resolved_at": self.resolved_at.isoformat() if self.resolved_at else None,
            "is_overdue": self.is_overdue,
            "days_open": self.days_open,
            "notes": self.notes,
        }


class RemediationTracker:
    """Track remediation workflow for vulnerabilities."""

    # Default SLA by severity (in days)
    DEFAULT_SLA = {
        Severity.CRITICAL: 7,
        Severity.HIGH: 30,
        Severity.MEDIUM: 90,
        Severity.LOW: 180,
        Severity.INFO: 365,
    }

    def __init__(self, sla_config: Optional[Dict[Severity, int]] = None) -> None:
        """Initialize tracker with optional SLA configuration."""
        self._tasks: Dict[str, RemediationTask] = {}
        self._sla = sla_config or self.DEFAULT_SLA.copy()
        self._task_counter = 0

    @property
    def tasks(self) -> List[RemediationTask]:
        """Get all tasks."""
        return list(self._tasks.values())

    def create_task(
        self,
        vulnerability: Vulnerability,
        assignee: Optional[str] = None,
        due_date: Optional[datetime] = None,
    ) -> RemediationTask:
        """Create a remediation task for a vulnerability."""
        self._task_counter += 1
        task_id = f"REM-{self._task_counter:05d}"

        # Set due date based on SLA if not provided
        if due_date is None:
            sla_days = self._sla.get(vulnerability.severity, 90)
            due_date = datetime.now() + timedelta(days=sla_days)

        task = RemediationTask(
            task_id=task_id,
            vulnerability=vulnerability,
            assignee=assignee,
            due_date=due_date,
        )

        self._tasks[task_id] = task
        return task

    def transition(
        self,
        task_id: str,
        new_status: RemediationStatus,
        note: Optional[str] = None,
    ) -> RemediationTask:
        """Transition task to new status."""
        if task_id not in self._tasks:
            raise ValueError(f"Task not found: {task_id}")

        task = self._tasks[task_id]
        current_status = task.status

        # Validate transition
        valid_next = VALID_TRANSITIONS.get(current_status, [])
        if new_status not in valid_next:
            raise ValueError(
                f"Invalid transition from {current_status.value} to {new_status.value}. "
                f"Valid transitions: {[s.value for s in valid_next]}"
            )

        # Update task
        task.status = new_status
        task.updated_at = datetime.now()

        if new_status == RemediationStatus.RESOLVED:
            task.resolved_at = datetime.now()

        # Record history
        history_entry = {
            "timestamp": task.updated_at.isoformat(),
            "action": "status_change",
            "from_status": current_status.value,
            "to_status": new_status.value,
        }
        if note:
            history_entry["note"] = note
            task.notes.append(note)

        task.history.append(history_entry)
        return task

    def assign(
        self, task_id: str, assignee: str, note: Optional[str] = None
    ) -> RemediationTask:
        """Assign task to a user."""
        if task_id not in self._tasks:
            raise ValueError(f"Task not found: {task_id}")

        task = self._tasks[task_id]
        old_assignee = task.assignee
        task.assignee = assignee
        task.updated_at = datetime.now()

        task.history.append({
            "timestamp": task.updated_at.isoformat(),
            "action": "assigned",
            "from_assignee": old_assignee,
            "to_assignee": assignee,
        })

        if note:
            task.notes.append(note)

        return task

    def update_due_date(
        self, task_id: str, due_date: datetime, reason: str
    ) -> RemediationTask:
        """Update task due date with reason."""
        if task_id not in self._tasks:
            raise ValueError(f"Task not found: {task_id}")

        task = self._tasks[task_id]
        old_due = task.due_date
        task.due_date = due_date
        task.updated_at = datetime.now()

        task.history.append({
            "timestamp": task.updated_at.isoformat(),
            "action": "due_date_change",
            "from_date": old_due.isoformat() if old_due else None,
            "to_date": due_date.isoformat(),
            "reason": reason,
        })

        return task

    def add_note(self, task_id: str, note: str) -> RemediationTask:
        """Add a note to a task."""
        if task_id not in self._tasks:
            raise ValueError(f"Task not found: {task_id}")

        task = self._tasks[task_id]
        task.notes.append(note)
        task.updated_at = datetime.now()

        task.history.append({
            "timestamp": task.updated_at.isoformat(),
            "action": "note_added",
            "note": note,
        })

        return task

    def get_task(self, task_id: str) -> Optional[RemediationTask]:
        """Get task by ID."""
        return self._tasks.get(task_id)

    def get_by_status(self, status: RemediationStatus) -> List[RemediationTask]:
        """Get tasks by status."""
        return [t for t in self._tasks.values() if t.status == status]

    def get_by_assignee(self, assignee: str) -> List[RemediationTask]:
        """Get tasks by assignee."""
        return [t for t in self._tasks.values() if t.assignee == assignee]

    def get_overdue(self) -> List[RemediationTask]:
        """Get all overdue tasks."""
        return [t for t in self._tasks.values() if t.is_overdue]

    def get_sla_violations(self) -> List[RemediationTask]:
        """Get tasks that have violated SLA."""
        violations = []
        for task in self._tasks.values():
            if task.status in (RemediationStatus.RESOLVED, RemediationStatus.FALSE_POSITIVE):
                if task.time_to_resolution:
                    sla_days = self._sla.get(task.vulnerability.severity, 90)
                    if task.time_to_resolution.days > sla_days:
                        violations.append(task)
            elif task.is_overdue:
                violations.append(task)
        return violations

    def sla_report(self) -> Dict[str, Any]:
        """Generate SLA compliance report."""
        total = len(self._tasks)
        if total == 0:
            return {"total": 0, "compliance_rate": 100.0, "overdue": 0, "violations": 0}

        overdue = len(self.get_overdue())
        violations = len(self.get_sla_violations())
        resolved = len(self.get_by_status(RemediationStatus.RESOLVED))
        resolved_in_sla = resolved - len([
            t for t in self.get_sla_violations()
            if t.status == RemediationStatus.RESOLVED
        ])

        compliance = (resolved_in_sla / resolved * 100) if resolved > 0 else 100.0

        return {
            "total": total,
            "resolved": resolved,
            "resolved_in_sla": resolved_in_sla,
            "compliance_rate": round(compliance, 2),
            "overdue": overdue,
            "violations": violations,
            "open": len(self.get_by_status(RemediationStatus.OPEN)),
            "in_progress": len(self.get_by_status(RemediationStatus.IN_PROGRESS)),
        }

    def statistics(self) -> Dict[str, Any]:
        """Get overall statistics."""
        status_counts = {s.value: 0 for s in RemediationStatus}
        for task in self._tasks.values():
            status_counts[task.status.value] += 1

        resolution_times = [
            t.time_to_resolution.days
            for t in self._tasks.values()
            if t.time_to_resolution
        ]
        avg_resolution = sum(resolution_times) / len(resolution_times) if resolution_times else 0

        return {
            "total_tasks": len(self._tasks),
            "by_status": status_counts,
            "overdue_count": len(self.get_overdue()),
            "avg_resolution_days": round(avg_resolution, 1),
            "sla_compliance": self.sla_report()["compliance_rate"],
        }
