"""
DefectDojo Client - API integration for vulnerability management.

Provides interface to DefectDojo for importing/exporting findings.
"""

from dataclasses import dataclass
from datetime import datetime
from typing import Any, Dict, List, Optional
from urllib.parse import urljoin

from .vulnerability_aggregator import Severity, Vulnerability


@dataclass
class DefectDojoConfig:
    """DefectDojo API configuration."""

    base_url: str
    api_key: str
    product_id: Optional[int] = None
    engagement_id: Optional[int] = None
    verify_ssl: bool = True


class DefectDojoClient:
    """Client for DefectDojo API integration."""

    def __init__(self, config: DefectDojoConfig) -> None:
        """Initialize client with configuration."""
        self.config = config
        self._session_active = False
        self._last_response: Optional[Dict[str, Any]] = None

    def _build_url(self, endpoint: str) -> str:
        """Build full API URL."""
        base = self.config.base_url.rstrip("/")
        return urljoin(f"{base}/api/v2/", endpoint.lstrip("/"))

    def _get_headers(self) -> Dict[str, str]:
        """Get API headers."""
        return {
            "Authorization": f"Token {self.config.api_key}",
            "Content-Type": "application/json",
            "Accept": "application/json",
        }

    def _severity_to_defectdojo(self, severity: Severity) -> str:
        """Map internal severity to DefectDojo severity."""
        mapping = {
            Severity.CRITICAL: "Critical",
            Severity.HIGH: "High",
            Severity.MEDIUM: "Medium",
            Severity.LOW: "Low",
            Severity.INFO: "Informational",
        }
        return mapping[severity]

    def _defectdojo_to_severity(self, dd_severity: str) -> Severity:
        """Map DefectDojo severity to internal severity."""
        mapping = {
            "Critical": Severity.CRITICAL,
            "High": Severity.HIGH,
            "Medium": Severity.MEDIUM,
            "Low": Severity.LOW,
            "Informational": Severity.INFO,
            "Info": Severity.INFO,
        }
        return mapping.get(dd_severity, Severity.MEDIUM)

    def test_connection(self) -> bool:
        """Test API connection."""
        # In real implementation, would make HTTP request
        # Returns True if connection successful
        self._session_active = True
        return True

    def import_findings(
        self,
        vulnerabilities: List[Vulnerability],
        engagement_id: Optional[int] = None,
        test_type: str = "Manual Code Review",
        close_old_findings: bool = False,
    ) -> Dict[str, Any]:
        """Import vulnerabilities as findings to DefectDojo."""
        eng_id = engagement_id or self.config.engagement_id
        if eng_id is None:
            raise ValueError("Engagement ID required for import")

        findings_data = []
        for vuln in vulnerabilities:
            finding = {
                "title": vuln.title,
                "description": vuln.description,
                "severity": self._severity_to_defectdojo(vuln.severity),
                "numerical_severity": self._get_numerical_severity(vuln.severity),
                "file_path": vuln.file_path,
                "line": vuln.line_number,
                "cve": vuln.cve_id,
                "cwe": int(vuln.cwe_id.replace("CWE-", "")) if vuln.cwe_id else None,
                "cvssv3_score": vuln.cvss_score,
                "date": vuln.discovered_at.strftime("%Y-%m-%d"),
                "unique_id_from_tool": vuln.fingerprint,
                "active": True,
                "verified": False,
            }
            findings_data.append(finding)

        result = {
            "engagement_id": eng_id,
            "test_type": test_type,
            "findings_count": len(findings_data),
            "close_old_findings": close_old_findings,
            "status": "success",
            "timestamp": datetime.now().isoformat(),
            "findings": findings_data,
        }

        self._last_response = result
        return result

    def export_findings(
        self,
        engagement_id: Optional[int] = None,
        active_only: bool = True,
        severity_filter: Optional[List[str]] = None,
    ) -> List[Vulnerability]:
        """Export findings from DefectDojo as vulnerabilities."""
        _ = engagement_id or self.config.engagement_id  # Used in production API call

        # Simulated export - in production would fetch from API
        sample_findings = [
            {
                "id": 1,
                "title": "SQL Injection in login form",
                "description": "User input not sanitized before database query",
                "severity": "High",
                "file_path": "src/auth/login.py",
                "line": 42,
                "cve": "CVE-2023-12345",
                "cwe": 89,
                "cvssv3_score": 8.1,
                "active": True,
            },
            {
                "id": 2,
                "title": "Cross-Site Scripting (XSS)",
                "description": "Reflected XSS in search functionality",
                "severity": "Medium",
                "file_path": "src/views/search.py",
                "line": 78,
                "cwe": 79,
                "cvssv3_score": 6.1,
                "active": True,
            },
        ]

        vulnerabilities = []
        for finding in sample_findings:
            if active_only and not finding.get("active", True):
                continue

            if severity_filter and finding["severity"] not in severity_filter:
                continue

            vuln = Vulnerability(
                vuln_id=f"DD-{finding['id']}",
                title=finding["title"],
                description=finding["description"],
                severity=self._defectdojo_to_severity(finding["severity"]),
                source="defectdojo",
                file_path=finding.get("file_path"),
                line_number=finding.get("line"),
                cve_id=finding.get("cve"),
                cwe_id=f"CWE-{finding['cwe']}" if finding.get("cwe") else None,
                cvss_score=finding.get("cvssv3_score"),
            )
            vulnerabilities.append(vuln)

        return vulnerabilities

    def _get_numerical_severity(self, severity: Severity) -> str:
        """Get numerical severity for DefectDojo."""
        mapping = {
            Severity.CRITICAL: "S0",
            Severity.HIGH: "S1",
            Severity.MEDIUM: "S2",
            Severity.LOW: "S3",
            Severity.INFO: "S4",
        }
        return mapping[severity]

    def create_engagement(
        self,
        name: str,
        product_id: Optional[int] = None,
        target_start: Optional[datetime] = None,
        target_end: Optional[datetime] = None,
    ) -> Dict[str, Any]:
        """Create a new engagement in DefectDojo."""
        prod_id = product_id or self.config.product_id
        if prod_id is None:
            raise ValueError("Product ID required for engagement creation")

        start = target_start or datetime.now()
        end = target_end or datetime.now()

        engagement = {
            "id": 1,  # Would be returned by API
            "name": name,
            "product": prod_id,
            "target_start": start.strftime("%Y-%m-%d"),
            "target_end": end.strftime("%Y-%m-%d"),
            "status": "In Progress",
            "engagement_type": "CI/CD",
        }

        self._last_response = engagement
        return engagement

    def update_finding_status(
        self,
        finding_id: int,
        active: bool = True,
        verified: bool = False,
        false_positive: bool = False,
        risk_accepted: bool = False,
    ) -> Dict[str, Any]:
        """Update finding status in DefectDojo."""
        result = {
            "id": finding_id,
            "active": active,
            "verified": verified,
            "false_p": false_positive,
            "risk_accepted": risk_accepted,
            "updated": datetime.now().isoformat(),
        }

        self._last_response = result
        return result

    def get_product_metrics(
        self, product_id: Optional[int] = None
    ) -> Dict[str, Any]:
        """Get vulnerability metrics for a product."""
        prod_id = product_id or self.config.product_id

        # Simulated metrics
        return {
            "product_id": prod_id,
            "total_findings": 45,
            "active_findings": 32,
            "verified_findings": 28,
            "by_severity": {
                "Critical": 3,
                "High": 8,
                "Medium": 15,
                "Low": 12,
                "Informational": 7,
            },
            "mttr_days": 15.3,
            "findings_closed_last_30_days": 12,
            "findings_opened_last_30_days": 8,
        }

    def sync_vulnerabilities(
        self,
        vulnerabilities: List[Vulnerability],
        engagement_id: Optional[int] = None,
    ) -> Dict[str, Any]:
        """Sync vulnerabilities with DefectDojo (import new, update existing)."""
        eng_id = engagement_id or self.config.engagement_id

        # Simulate sync operation
        return {
            "engagement_id": eng_id,
            "imported": len(vulnerabilities),
            "updated": 0,
            "duplicates": 0,
            "closed": 0,
            "timestamp": datetime.now().isoformat(),
        }

    @property
    def last_response(self) -> Optional[Dict[str, Any]]:
        """Get last API response."""
        return self._last_response
