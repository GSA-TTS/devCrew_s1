"""
Vulnerability Aggregator - SARIF/JSON/XML parser with deduplication.

Parses vulnerability reports from various scanners and normalizes them.
"""

import hashlib
import json
import xml.etree.ElementTree as ET
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from pathlib import Path
from typing import Any, Dict, List, Optional


class Severity(Enum):
    """Vulnerability severity levels."""

    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"


@dataclass
class Vulnerability:
    """Normalized vulnerability representation."""

    vuln_id: str
    title: str
    description: str
    severity: Severity
    source: str
    file_path: Optional[str] = None
    line_number: Optional[int] = None
    cve_id: Optional[str] = None
    cwe_id: Optional[str] = None
    cvss_score: Optional[float] = None
    fingerprint: str = ""
    discovered_at: datetime = field(default_factory=datetime.now)
    metadata: Dict[str, Any] = field(default_factory=dict)

    def __post_init__(self) -> None:
        """Generate fingerprint if not provided."""
        if not self.fingerprint:
            self.fingerprint = self._generate_fingerprint()

    def _generate_fingerprint(self) -> str:
        """Generate unique fingerprint for deduplication."""
        components = [
            self.title,
            self.file_path or "",
            str(self.line_number or ""),
            self.cve_id or "",
            self.cwe_id or "",
        ]
        content = "|".join(components)
        return hashlib.sha256(content.encode()).hexdigest()[:32]

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            "vuln_id": self.vuln_id,
            "title": self.title,
            "description": self.description,
            "severity": self.severity.value,
            "source": self.source,
            "file_path": self.file_path,
            "line_number": self.line_number,
            "cve_id": self.cve_id,
            "cwe_id": self.cwe_id,
            "cvss_score": self.cvss_score,
            "fingerprint": self.fingerprint,
            "discovered_at": self.discovered_at.isoformat(),
            "metadata": self.metadata,
        }


class VulnerabilityAggregator:
    """Aggregates vulnerabilities from multiple sources with deduplication."""

    def __init__(self) -> None:
        """Initialize aggregator."""
        self._vulnerabilities: Dict[str, Vulnerability] = {}
        self._sources: List[str] = []

    @property
    def vulnerabilities(self) -> List[Vulnerability]:
        """Get all unique vulnerabilities."""
        return list(self._vulnerabilities.values())

    @property
    def sources(self) -> List[str]:
        """Get list of processed sources."""
        return self._sources.copy()

    def parse_sarif(self, file_path: str) -> List[Vulnerability]:
        """Parse SARIF format vulnerability report."""
        path = Path(file_path)
        if not path.exists():
            raise FileNotFoundError(f"SARIF file not found: {file_path}")

        with open(path, "r", encoding="utf-8") as f:
            data = json.load(f)

        vulnerabilities: List[Vulnerability] = []
        source = path.name

        for run in data.get("runs", []):
            tool_name = run.get("tool", {}).get("driver", {}).get("name", "unknown")
            rules = {
                r["id"]: r for r in run.get("tool", {}).get("driver", {}).get("rules", [])
            }

            for result in run.get("results", []):
                rule_id = result.get("ruleId", "unknown")
                rule = rules.get(rule_id, {})

                # Extract location info
                locations = result.get("locations", [])
                file_location = None
                line_num = None
                if locations:
                    phys_loc = locations[0].get("physicalLocation", {})
                    artifact = phys_loc.get("artifactLocation", {})
                    file_location = artifact.get("uri")
                    region = phys_loc.get("region", {})
                    line_num = region.get("startLine")

                # Map severity
                level = result.get("level", "warning")
                severity = self._map_sarif_level(level)

                # Extract CWE if available
                cwe_id = None
                for tag in rule.get("properties", {}).get("tags", []):
                    if tag.startswith("CWE-"):
                        cwe_id = tag
                        break

                vuln = Vulnerability(
                    vuln_id=f"{tool_name}-{rule_id}-{len(vulnerabilities)}",
                    title=rule.get("shortDescription", {}).get("text", rule_id),
                    description=result.get("message", {}).get("text", ""),
                    severity=severity,
                    source=source,
                    file_path=file_location,
                    line_number=line_num,
                    cwe_id=cwe_id,
                    metadata={"tool": tool_name, "rule_id": rule_id},
                )
                vulnerabilities.append(vuln)

        self._add_vulnerabilities(vulnerabilities, source)
        return vulnerabilities

    def parse_json(self, file_path: str) -> List[Vulnerability]:
        """Parse generic JSON vulnerability report."""
        path = Path(file_path)
        if not path.exists():
            raise FileNotFoundError(f"JSON file not found: {file_path}")

        with open(path, "r", encoding="utf-8") as f:
            data = json.load(f)

        vulnerabilities: List[Vulnerability] = []
        source = path.name

        # Handle list of vulnerabilities or single object with vulnerabilities key
        vuln_list = data if isinstance(data, list) else data.get("vulnerabilities", [])

        for idx, item in enumerate(vuln_list):
            severity_str = item.get("severity", "medium").lower()
            severity = Severity(severity_str) if severity_str in [s.value for s in Severity] else Severity.MEDIUM

            vuln = Vulnerability(
                vuln_id=item.get("id", f"json-{idx}"),
                title=item.get("title", "Unknown"),
                description=item.get("description", ""),
                severity=severity,
                source=source,
                file_path=item.get("file_path") or item.get("location"),
                line_number=item.get("line_number") or item.get("line"),
                cve_id=item.get("cve_id") or item.get("cve"),
                cwe_id=item.get("cwe_id") or item.get("cwe"),
                cvss_score=item.get("cvss_score") or item.get("cvss"),
                metadata=item.get("metadata", {}),
            )
            vulnerabilities.append(vuln)

        self._add_vulnerabilities(vulnerabilities, source)
        return vulnerabilities

    def parse_xml(self, file_path: str) -> List[Vulnerability]:
        """Parse XML vulnerability report (e.g., OWASP ZAP, Nessus format)."""
        path = Path(file_path)
        if not path.exists():
            raise FileNotFoundError(f"XML file not found: {file_path}")

        tree = ET.parse(path)
        root = tree.getroot()

        vulnerabilities: List[Vulnerability] = []
        source = path.name

        # Support multiple XML formats
        for vuln_elem in root.findall(".//vulnerability") or root.findall(".//issue") or root.findall(".//alertitem"):
            vuln = self._parse_xml_vulnerability(vuln_elem, source, len(vulnerabilities))
            if vuln:
                vulnerabilities.append(vuln)

        self._add_vulnerabilities(vulnerabilities, source)
        return vulnerabilities

    def _parse_xml_vulnerability(
        self, elem: ET.Element, source: str, idx: int
    ) -> Optional[Vulnerability]:
        """Parse single XML vulnerability element."""
        def get_text(tag: str) -> Optional[str]:
            child = elem.find(tag)
            return child.text if child is not None else None

        title = get_text("name") or get_text("title") or "Unknown"
        description = get_text("description") or get_text("desc") or ""
        severity_str = (get_text("severity") or get_text("risk") or "medium").lower()

        # Map common severity strings
        severity_map = {
            "4": Severity.CRITICAL,
            "3": Severity.HIGH,
            "2": Severity.MEDIUM,
            "1": Severity.LOW,
            "0": Severity.INFO,
        }
        if severity_str in severity_map:
            severity = severity_map[severity_str]
        elif severity_str in [s.value for s in Severity]:
            severity = Severity(severity_str)
        else:
            severity = Severity.MEDIUM

        return Vulnerability(
            vuln_id=get_text("id") or f"xml-{idx}",
            title=title,
            description=description,
            severity=severity,
            source=source,
            file_path=get_text("file") or get_text("uri") or get_text("url"),
            line_number=int(get_text("line") or 0) or None,
            cve_id=get_text("cve"),
            cwe_id=get_text("cwe") or get_text("cweid"),
            cvss_score=float(get_text("cvss") or 0) or None,
        )

    def _map_sarif_level(self, level: str) -> Severity:
        """Map SARIF level to Severity."""
        mapping = {
            "error": Severity.HIGH,
            "warning": Severity.MEDIUM,
            "note": Severity.LOW,
            "none": Severity.INFO,
        }
        return mapping.get(level, Severity.MEDIUM)

    def _add_vulnerabilities(
        self, vulnerabilities: List[Vulnerability], source: str
    ) -> None:
        """Add vulnerabilities with deduplication."""
        if source not in self._sources:
            self._sources.append(source)

        for vuln in vulnerabilities:
            if vuln.fingerprint not in self._vulnerabilities:
                self._vulnerabilities[vuln.fingerprint] = vuln

    def deduplicate(self) -> int:
        """Return count of unique vulnerabilities after deduplication."""
        return len(self._vulnerabilities)

    def get_by_severity(self, severity: Severity) -> List[Vulnerability]:
        """Get vulnerabilities by severity level."""
        return [v for v in self._vulnerabilities.values() if v.severity == severity]

    def get_by_cwe(self, cwe_id: str) -> List[Vulnerability]:
        """Get vulnerabilities by CWE ID."""
        return [v for v in self._vulnerabilities.values() if v.cwe_id == cwe_id]

    def export_json(self, file_path: str) -> None:
        """Export all vulnerabilities to JSON."""
        data = [v.to_dict() for v in self._vulnerabilities.values()]
        with open(file_path, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=2)

    def clear(self) -> None:
        """Clear all vulnerabilities."""
        self._vulnerabilities.clear()
        self._sources.clear()

    def statistics(self) -> Dict[str, Any]:
        """Get aggregated statistics."""
        severity_counts = {s.value: 0 for s in Severity}
        for vuln in self._vulnerabilities.values():
            severity_counts[vuln.severity.value] += 1

        return {
            "total": len(self._vulnerabilities),
            "by_severity": severity_counts,
            "sources": len(self._sources),
            "with_cve": sum(1 for v in self._vulnerabilities.values() if v.cve_id),
            "with_cwe": sum(1 for v in self._vulnerabilities.values() if v.cwe_id),
        }
