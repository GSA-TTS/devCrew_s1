"""
Risk Scorer - CVSS 3.1/4.0 calculation and vulnerability prioritization.

Implements Common Vulnerability Scoring System calculations.
"""

import math
from dataclasses import dataclass
from enum import Enum
from typing import Any, Dict, List, Optional

from .vulnerability_aggregator import Severity, Vulnerability


class AttackVector(Enum):
    """CVSS Attack Vector metric."""

    NETWORK = "N"
    ADJACENT = "A"
    LOCAL = "L"
    PHYSICAL = "P"


class AttackComplexity(Enum):
    """CVSS Attack Complexity metric."""

    LOW = "L"
    HIGH = "H"


class PrivilegesRequired(Enum):
    """CVSS Privileges Required metric."""

    NONE = "N"
    LOW = "L"
    HIGH = "H"


class UserInteraction(Enum):
    """CVSS User Interaction metric."""

    NONE = "N"
    REQUIRED = "R"


class Scope(Enum):
    """CVSS Scope metric."""

    UNCHANGED = "U"
    CHANGED = "C"


class Impact(Enum):
    """CVSS Impact metric (C/I/A)."""

    NONE = "N"
    LOW = "L"
    HIGH = "H"


class ExploitCodeMaturity(Enum):
    """CVSS Temporal - Exploit Code Maturity."""

    NOT_DEFINED = "X"
    HIGH = "H"
    FUNCTIONAL = "F"
    PROOF_OF_CONCEPT = "P"
    UNPROVEN = "U"


class RemediationLevel(Enum):
    """CVSS Temporal - Remediation Level."""

    NOT_DEFINED = "X"
    UNAVAILABLE = "U"
    WORKAROUND = "W"
    TEMPORARY_FIX = "T"
    OFFICIAL_FIX = "O"


class ReportConfidence(Enum):
    """CVSS Temporal - Report Confidence."""

    NOT_DEFINED = "X"
    CONFIRMED = "C"
    REASONABLE = "R"
    UNKNOWN = "U"


@dataclass
class CVSSVector:
    """CVSS 3.1 Vector representation."""

    # Base metrics (required)
    attack_vector: AttackVector = AttackVector.NETWORK
    attack_complexity: AttackComplexity = AttackComplexity.LOW
    privileges_required: PrivilegesRequired = PrivilegesRequired.NONE
    user_interaction: UserInteraction = UserInteraction.NONE
    scope: Scope = Scope.UNCHANGED
    confidentiality_impact: Impact = Impact.HIGH
    integrity_impact: Impact = Impact.HIGH
    availability_impact: Impact = Impact.HIGH

    # Temporal metrics (optional)
    exploit_code_maturity: ExploitCodeMaturity = ExploitCodeMaturity.NOT_DEFINED
    remediation_level: RemediationLevel = RemediationLevel.NOT_DEFINED
    report_confidence: ReportConfidence = ReportConfidence.NOT_DEFINED

    # Environmental adjustments
    confidentiality_requirement: str = "X"  # X, L, M, H
    integrity_requirement: str = "X"
    availability_requirement: str = "X"

    def to_vector_string(self) -> str:
        """Generate CVSS vector string."""
        return (
            f"CVSS:3.1/AV:{self.attack_vector.value}/AC:{self.attack_complexity.value}/"
            f"PR:{self.privileges_required.value}/UI:{self.user_interaction.value}/"
            f"S:{self.scope.value}/C:{self.confidentiality_impact.value}/"
            f"I:{self.integrity_impact.value}/A:{self.availability_impact.value}"
        )

    @classmethod
    def from_vector_string(cls, vector: str) -> "CVSSVector":
        """Parse CVSS vector string."""
        parts = vector.replace("CVSS:3.1/", "").replace("CVSS:3.0/", "").split("/")
        metrics: Dict[str, str] = {}
        for part in parts:
            if ":" in part:
                key, value = part.split(":", 1)
                metrics[key] = value

        return cls(
            attack_vector=AttackVector(metrics.get("AV", "N")),
            attack_complexity=AttackComplexity(metrics.get("AC", "L")),
            privileges_required=PrivilegesRequired(metrics.get("PR", "N")),
            user_interaction=UserInteraction(metrics.get("UI", "N")),
            scope=Scope(metrics.get("S", "U")),
            confidentiality_impact=Impact(metrics.get("C", "N")),
            integrity_impact=Impact(metrics.get("I", "N")),
            availability_impact=Impact(metrics.get("A", "N")),
        )


class RiskScorer:
    """Calculate CVSS scores and prioritize vulnerabilities."""

    # CVSS 3.1 metric weights
    AV_WEIGHTS = {"N": 0.85, "A": 0.62, "L": 0.55, "P": 0.2}
    AC_WEIGHTS = {"L": 0.77, "H": 0.44}
    PR_WEIGHTS_UNCHANGED = {"N": 0.85, "L": 0.62, "H": 0.27}
    PR_WEIGHTS_CHANGED = {"N": 0.85, "L": 0.68, "H": 0.50}
    UI_WEIGHTS = {"N": 0.85, "R": 0.62}
    IMPACT_WEIGHTS = {"N": 0, "L": 0.22, "H": 0.56}

    # Temporal weights
    E_WEIGHTS = {"X": 1.0, "H": 1.0, "F": 0.97, "P": 0.94, "U": 0.91}
    RL_WEIGHTS = {"X": 1.0, "U": 1.0, "W": 0.97, "T": 0.96, "O": 0.95}
    RC_WEIGHTS = {"X": 1.0, "C": 1.0, "R": 0.96, "U": 0.92}

    # Environmental requirement weights
    REQ_WEIGHTS = {"X": 1.0, "L": 0.5, "M": 1.0, "H": 1.5}

    def __init__(self) -> None:
        """Initialize risk scorer."""
        self._scored_vulnerabilities: Dict[str, float] = {}

    def calculate_base_score(self, vector: CVSSVector) -> float:
        """Calculate CVSS 3.1 base score."""
        # Exploitability sub-score
        av = self.AV_WEIGHTS[vector.attack_vector.value]
        ac = self.AC_WEIGHTS[vector.attack_complexity.value]

        if vector.scope == Scope.CHANGED:
            pr = self.PR_WEIGHTS_CHANGED[vector.privileges_required.value]
        else:
            pr = self.PR_WEIGHTS_UNCHANGED[vector.privileges_required.value]

        ui = self.UI_WEIGHTS[vector.user_interaction.value]
        exploitability = 8.22 * av * ac * pr * ui

        # Impact sub-score
        isc_base = 1 - (
            (1 - self.IMPACT_WEIGHTS[vector.confidentiality_impact.value])
            * (1 - self.IMPACT_WEIGHTS[vector.integrity_impact.value])
            * (1 - self.IMPACT_WEIGHTS[vector.availability_impact.value])
        )

        if vector.scope == Scope.UNCHANGED:
            impact = 6.42 * isc_base
        else:
            impact = 7.52 * (isc_base - 0.029) - 3.25 * pow(isc_base - 0.02, 15)

        # Base score calculation
        if impact <= 0:
            return 0.0

        if vector.scope == Scope.UNCHANGED:
            base_score = min(impact + exploitability, 10)
        else:
            base_score = min(1.08 * (impact + exploitability), 10)

        return round(base_score * 10) / 10

    def calculate_temporal_score(
        self, base_score: float, vector: CVSSVector
    ) -> float:
        """Calculate CVSS 3.1 temporal score."""
        e = self.E_WEIGHTS[vector.exploit_code_maturity.value]
        rl = self.RL_WEIGHTS[vector.remediation_level.value]
        rc = self.RC_WEIGHTS[vector.report_confidence.value]

        temporal = base_score * e * rl * rc
        return round(temporal * 10) / 10

    def calculate_environmental_score(
        self, vector: CVSSVector
    ) -> float:
        """Calculate CVSS 3.1 environmental score with modified metrics."""
        cr = self.REQ_WEIGHTS[vector.confidentiality_requirement]
        ir = self.REQ_WEIGHTS[vector.integrity_requirement]
        ar = self.REQ_WEIGHTS[vector.availability_requirement]

        # Modified impact
        c_mod = self.IMPACT_WEIGHTS[vector.confidentiality_impact.value]
        i_mod = self.IMPACT_WEIGHTS[vector.integrity_impact.value]
        a_mod = self.IMPACT_WEIGHTS[vector.availability_impact.value]

        miss = min(
            1 - (1 - c_mod * cr) * (1 - i_mod * ir) * (1 - a_mod * ar),
            0.915
        )

        if vector.scope == Scope.UNCHANGED:
            modified_impact = 6.42 * miss
        else:
            modified_impact = 7.52 * (miss - 0.029) - 3.25 * pow(max(miss - 0.02, 0), 15)

        # Exploitability
        av = self.AV_WEIGHTS[vector.attack_vector.value]
        ac = self.AC_WEIGHTS[vector.attack_complexity.value]
        if vector.scope == Scope.CHANGED:
            pr = self.PR_WEIGHTS_CHANGED[vector.privileges_required.value]
        else:
            pr = self.PR_WEIGHTS_UNCHANGED[vector.privileges_required.value]
        ui = self.UI_WEIGHTS[vector.user_interaction.value]
        exploitability = 8.22 * av * ac * pr * ui

        if modified_impact <= 0:
            return 0.0

        if vector.scope == Scope.UNCHANGED:
            env_score = min(modified_impact + exploitability, 10)
        else:
            env_score = min(1.08 * (modified_impact + exploitability), 10)

        # Apply temporal factors
        e = self.E_WEIGHTS[vector.exploit_code_maturity.value]
        rl = self.RL_WEIGHTS[vector.remediation_level.value]
        rc = self.RC_WEIGHTS[vector.report_confidence.value]

        return round(env_score * e * rl * rc * 10) / 10

    def score_vulnerability(
        self,
        vulnerability: Vulnerability,
        vector: Optional[CVSSVector] = None,
    ) -> float:
        """Score a vulnerability using CVSS or estimate from severity."""
        if vulnerability.cvss_score is not None:
            score = vulnerability.cvss_score
        elif vector:
            score = self.calculate_base_score(vector)
        else:
            # Estimate from severity
            severity_scores = {
                Severity.CRITICAL: 9.5,
                Severity.HIGH: 7.5,
                Severity.MEDIUM: 5.0,
                Severity.LOW: 2.5,
                Severity.INFO: 0.5,
            }
            score = severity_scores[vulnerability.severity]

        self._scored_vulnerabilities[vulnerability.fingerprint] = score
        return score

    def prioritize(
        self,
        vulnerabilities: List[Vulnerability],
        weights: Optional[Dict[str, float]] = None,
    ) -> List[Vulnerability]:
        """Prioritize vulnerabilities by risk score."""
        if weights is None:
            weights = {"cvss": 1.0, "age": 0.1, "exploitability": 0.2}

        scored: List[tuple[float, Vulnerability]] = []
        for vuln in vulnerabilities:
            base_score = self._scored_vulnerabilities.get(
                vuln.fingerprint, self.score_vulnerability(vuln)
            )

            # Apply weights
            final_score = base_score * weights.get("cvss", 1.0)

            # Boost for CVE presence (indicates known exploitability)
            if vuln.cve_id:
                final_score *= 1 + weights.get("exploitability", 0.0)

            scored.append((final_score, vuln))

        scored.sort(key=lambda x: x[0], reverse=True)
        return [v for _, v in scored]

    def severity_from_score(self, score: float) -> Severity:
        """Convert CVSS score to severity rating."""
        if score >= 9.0:
            return Severity.CRITICAL
        elif score >= 7.0:
            return Severity.HIGH
        elif score >= 4.0:
            return Severity.MEDIUM
        elif score >= 0.1:
            return Severity.LOW
        else:
            return Severity.INFO

    def get_risk_summary(
        self, vulnerabilities: List[Vulnerability]
    ) -> Dict[str, Any]:
        """Get risk summary statistics."""
        if not vulnerabilities:
            return {"total": 0, "average_score": 0, "max_score": 0, "risk_level": "none"}

        scores = [
            self._scored_vulnerabilities.get(v.fingerprint, self.score_vulnerability(v))
            for v in vulnerabilities
        ]

        avg_score = sum(scores) / len(scores)
        max_score = max(scores)

        risk_level = self.severity_from_score(max_score).value

        return {
            "total": len(vulnerabilities),
            "average_score": round(avg_score, 2),
            "max_score": max_score,
            "min_score": min(scores),
            "risk_level": risk_level,
            "critical_count": sum(1 for s in scores if s >= 9.0),
            "high_count": sum(1 for s in scores if 7.0 <= s < 9.0),
            "medium_count": sum(1 for s in scores if 4.0 <= s < 7.0),
            "low_count": sum(1 for s in scores if 0.1 <= s < 4.0),
        }
